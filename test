#!/usr/bin/env python3
“””
YAML Alphabetical Sorter (No External Dependencies)
Sorts YAML files alphabetically while preserving content and structure.
Uses only Python built-in modules - no PyYAML required.
“””

import sys
import argparse
import re
from pathlib import Path
from collections import OrderedDict

class SimpleYAMLParser:
“”“Simple YAML parser that handles basic YAML structure for sorting.”””

```
def __init__(self):
    self.lines = []
    self.current_line = 0

def parse_file(self, file_path):
    """Parse a YAML file and return structured data."""
    with open(file_path, 'r', encoding='utf-8') as f:
        self.lines = f.readlines()
    
    self.current_line = 0
    return self._parse_document()

def _parse_document(self):
    """Parse the entire YAML document."""
    result = {}
    
    while self.current_line < len(self.lines):
        line = self.lines[self.current_line].rstrip('\n\r')
        
        # Skip empty lines and comments
        if not line.strip() or line.strip().startswith('#'):
            self.current_line += 1
            continue
        
        # Check for document separators
        if line.strip() in ['---', '...']:
            self.current_line += 1
            continue
        
        # Parse key-value pairs at root level
        if ':' in line and not line.startswith(' '):
            key, value = self._parse_key_value(line)
            if value is None:
                # Multi-line value or nested structure
                result[key] = self._parse_nested_structure()
            else:
                result[key] = value
        else:
            self.current_line += 1
    
    return result

def _parse_key_value(self, line):
    """Parse a key-value pair from a line."""
    if ':' not in line:
        return None, None
    
    key_part, value_part = line.split(':', 1)
    key = key_part.strip()
    value = value_part.strip()
    
    if not value:
        return key, None
    
    # Handle quoted strings
    if (value.startswith('"') and value.endswith('"')) or \
       (value.startswith("'") and value.endswith("'")):
        return key, value[1:-1]
    
    # Handle boolean values
    if value.lower() in ['true', 'false']:
        return key, value.lower() == 'true'
    
    # Handle numbers
    try:
        if '.' in value:
            return key, float(value)
        else:
            return key, int(value)
    except ValueError:
        pass
    
    return key, value

def _parse_nested_structure(self):
    """Parse nested structure (dict or list)."""
    self.current_line += 1
    base_indent = self._get_indent_level()
    
    # Check if it's a list
    if self.current_line < len(self.lines):
        line = self.lines[self.current_line].rstrip('\n\r')
        if line.strip().startswith('-'):
            return self._parse_list(base_indent)
    
    # Parse as dictionary
    return self._parse_dict(base_indent)

def _parse_dict(self, base_indent):
    """Parse a dictionary structure."""
    result = {}
    
    while self.current_line < len(self.lines):
        line = self.lines[self.current_line].rstrip('\n\r')
        
        # Skip empty lines and comments
        if not line.strip() or line.strip().startswith('#'):
            self.current_line += 1
            continue
        
        current_indent = len(line) - len(line.lstrip())
        
        # If we've gone back to a lower indentation level, we're done
        if current_indent < base_indent:
            break
        
        # If we're at the same level, parse key-value
        if current_indent == base_indent and ':' in line:
            key, value = self._parse_key_value(line)
            if value is None:
                result[key] = self._parse_nested_structure()
            else:
                result[key] = value
        else:
            self.current_line += 1
    
    return result

def _parse_list(self, base_indent):
    """Parse a list structure."""
    result = []
    
    while self.current_line < len(self.lines):
        line = self.lines[self.current_line].rstrip('\n\r')
        
        # Skip empty lines and comments
        if not line.strip() or line.strip().startswith('#'):
            self.current_line += 1
            continue
        
        current_indent = len(line) - len(line.lstrip())
        
        # If we've gone back to a lower indentation level, we're done
        if current_indent < base_indent:
            break
        
        # Parse list item
        if current_indent == base_indent and line.strip().startswith('-'):
            item_content = line.strip()[1:].strip()
            if ':' in item_content:
                # Dictionary item
                key, value = self._parse_key_value(item_content)
                if value is None:
                    item_dict = {key: self._parse_nested_structure()}
                else:
                    item_dict = {key: value}
                result.append(item_dict)
            else:
                # Simple item
                result.append(item_content)
        else:
            self.current_line += 1
    
    return result

def _get_indent_level(self):
    """Get the indentation level of the current line."""
    if self.current_line >= len(self.lines):
        return 0
    
    line = self.lines[self.current_line]
    return len(line) - len(line.lstrip())
```

class SimpleYAMLWriter:
“”“Simple YAML writer that outputs sorted YAML.”””

```
def __init__(self):
    self.output = []

def write_to_file(self, data, file_path):
    """Write data structure to YAML file."""
    self.output = []
    self._write_value(data, 0)
    
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(self.output))
        if self.output:  # Add final newline if content exists
            f.write('\n')

def _write_value(self, value, indent_level):
    """Write a value at the given indentation level."""
    indent = '  ' * indent_level
    
    if isinstance(value, dict):
        for key in sorted(value.keys()):
            self._write_dict_item(key, value[key], indent_level)
    elif isinstance(value, list):
        for item in value:
            self._write_list_item(item, indent_level)
    else:
        # This shouldn't happen at root level
        self.output.append(f"{indent}{self._format_value(value)}")

def _write_dict_item(self, key, value, indent_level):
    """Write a dictionary key-value pair."""
    indent = '  ' * indent_level
    
    if isinstance(value, dict):
        self.output.append(f"{indent}{key}:")
        self._write_value(value, indent_level + 1)
    elif isinstance(value, list):
        self.output.append(f"{indent}{key}:")
        for item in value:
            self._write_list_item(item, indent_level + 1)
    else:
        formatted_value = self._format_value(value)
        self.output.append(f"{indent}{key}: {formatted_value}")

def _write_list_item(self, item, indent_level):
    """Write a list item."""
    indent = '  ' * indent_level
    
    if isinstance(item, dict):
        if len(item) == 1:
            # Single key-value pair in list item
            key, value = next(iter(item.items()))
            if isinstance(value, (dict, list)):
                self.output.append(f"{indent}- {key}:")
                self._write_value(value, indent_level + 1)
            else:
                formatted_value = self._format_value(value)
                self.output.append(f"{indent}- {key}: {formatted_value}")
        else:
            # Multiple key-value pairs
            self.output.append(f"{indent}-")
            self._write_value(item, indent_level + 1)
    elif isinstance(item, list):
        self.output.append(f"{indent}-")
        for subitem in item:
            self._write_list_item(subitem, indent_level + 1)
    else:
        formatted_value = self._format_value(item)
        self.output.append(f"{indent}- {formatted_value}")

def _format_value(self, value):
    """Format a value for YAML output."""
    if isinstance(value, str):
        # Quote strings that contain special characters or look like other types
        if (value.lower() in ['true', 'false', 'null'] or 
            re.match(r'^-?\d+(\.\d+)?$', value) or
            any(char in value for char in [':', '#', '[', ']', '{', '}', '|', '>', '\n'])):
            return f'"{value}"'
        return value
    elif isinstance(value, bool):
        return 'true' if value else 'false'
    elif value is None:
        return 'null'
    else:
        return str(value)
```

def sort_yaml_recursively(data):
“”“Recursively sort YAML data alphabetically.”””
if isinstance(data, dict):
sorted_dict = OrderedDict()
for key in sorted(data.keys()):
sorted_dict[key] = sort_yaml_recursively(data[key])
return sorted_dict
elif isinstance(data, list):
return [sort_yaml_recursively(item) for item in data]
else:
return data

def format_yaml_file(input_file, output_file=None):
“”“Read a YAML file, sort it alphabetically, and write it back.”””
try:
# Parse the YAML file
parser = SimpleYAMLParser()
data = parser.parse_file(input_file)

```
    # Sort the data alphabetically
    sorted_data = sort_yaml_recursively(data)
    
    # Determine output file
    if output_file is None:
        output_file = input_file
    
    # Write the sorted YAML back
    writer = SimpleYAMLWriter()
    writer.write_to_file(sorted_data, output_file)
    
    print(f"Successfully sorted {input_file}")
    if output_file != input_file:
        print(f"Output written to {output_file}")
        
except FileNotFoundError:
    print(f"Error: File '{input_file}' not found.")
    sys.exit(1)
except Exception as e:
    print(f"Error processing file '{input_file}': {e}")
    sys.exit(1)
```

def main():
parser = argparse.ArgumentParser(
description=‘Sort YAML files alphabetically for easier comparison (no external dependencies)’,
formatter_class=argparse.RawDescriptionHelpFormatter,
epilog=’’’
Examples:

# Sort a single file in-place

python yaml_sorter.py deployment.yaml

# Sort multiple files

python yaml_sorter.py file1.yaml file2.yaml

# Sort with custom output file

python yaml_sorter.py input.yaml -o sorted_output.yaml
‘’’
)

```
parser.add_argument('files', nargs='+', help='YAML files to sort')
parser.add_argument('-o', '--output', 
                   help='Output file (only valid when sorting a single file)')
parser.add_argument('--backup', action='store_true',
                   help='Create backup files (.bak) before sorting')

args = parser.parse_args()

# Validate arguments
if args.output and len(args.files) > 1:
    print("Error: --output can only be used with a single input file")
    sys.exit(1)

# Process each file
for file_path in args.files:
    if not Path(file_path).exists():
        print(f"Error: File '{file_path}' does not exist")
        continue
    
    # Create backup if requested
    if args.backup:
        backup_path = f"{file_path}.bak"
        Path(file_path).replace(backup_path)
        print(f"Created backup: {backup_path}")
    
    # Sort the file
    output_file = args.output if args.output else None
    format_yaml_file(file_path, output_file)
```

if **name** == ‘**main**’:
main()